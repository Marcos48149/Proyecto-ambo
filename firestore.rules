/**
 * @file Firestore Security Rules for e-commerce application.
 *
 * @core_philosophy This ruleset enforces a hybrid security model:
 *   - User-owned data (profiles, cart items, orders) is strictly controlled by the user's authentication status and UID.
 *   - Product data is publicly readable but only writable by authorized roles (not yet implemented in this prototype).
 *   - A root /orders collection is open for writing to support anonymous POS sales.
 *
 * @data_structure
 *   - /users/{userId}: Stores user profile information.
 *   - /products/{productId}: Stores product details.
 *   - /users/{userId}/cartItems/{cartItemId}: Stores cart items for each user.
 *   - /users/{userId}/orders/{orderId}: Stores order information for each user.
 *   - /users/{userId}/orders/{orderId}/orderItems/{orderItemId}: Stores individual items within an order.
 *   - /orders/{orderId}: Root collection for all orders, including anonymous orders.
 *
 * @key_security_decisions
 *   - Users can only access their own data under /users/{userId}.
 *   - Products are publicly readable. Write access to products is not yet restricted to specific roles in this prototype but MUST be implemented in production.
 *   - Listing of users is disallowed.
 *   - The /orders collection is open for create operations to support anonymous sales, but this MUST be revisited in production.
 *
 * @denormalization_for_authorization
 *   - Cart items include a 'userId' field to allow direct rule enforcement without requiring a get() on the parent /users/{userId} document.
 *
 * @structural_segregation
 *   - Orders are primarily stored under the user's document (/users/{userId}/orders/{orderId}) to ensure that users can only access their own order history.
 *   - A root `/orders` collection is maintained for admin-level queries and anonymous POS sales.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures user profile data, ensuring only the authenticated user can access their own profile.
     * @path /users/{userId}
     * @allow (read, write) if the authenticated user's UID matches the {userId} path segment.
     * @deny (read, write) if the authenticated user's UID does not match the {userId} path segment.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false; // Listing users is not permitted.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Secures product data, allowing public read access but restricting writes.
     * @path /products/{productId}
     * @allow (read) to anyone.
     * @deny (create, update, delete) to non-admin users.
     * @principle Allows public read access while restricting write access to authorized roles.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin role check
    }

    /**
     * @description Secures cart items, ensuring only the owner can manage their own cart.
     * @path /users/{userId}/cartItems/{cartItemId}
     * @allow (read, write) if the authenticated user's UID matches the {userId} path segment.
     * @deny (read, write) if the authenticated user's UID does not match the {userId} path segment.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/cartItems/{cartItemId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Secures order data, ensuring only the owner can manage their own orders.
     * @path /users/{userId}/orders/{orderId}
     * @allow (read, write) if the authenticated user's UID matches the {userId} path segment.
     * @deny (read, write) if the authenticated user's UID does not match the {userId} path segment.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/orders/{orderId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);

      /**
       * @description Secures order items, ensuring only the owner can manage items within their own orders.
       * @path /users/{userId}/orders/{orderId}/orderItems/{orderItemId}
       */
      match /orderItems/{orderItemId} {
        allow get: if isSignedIn() && isOwner(userId);
        allow list: if isSignedIn() && isOwner(userId);
        allow create: if isSignedIn() && isOwner(userId);
        allow update: if isSignedIn() && isExistingOwner(userId);
        allow delete: if isSignedIn() && isExistingOwner(userId);
      }
    }

      /**
       * @description Open access to the /orders collection to allow for anonymous POS sales
       * @path /orders/{orderId}
       * @allow create to any signed-in user for prototyping
       * @principle Read access is forbidden, and the `create` rule should be revisited in production
       */
      match /orders/{orderId} {
        allow get, list: if false;
        allow create: if true;
        allow update, delete: if false;
    }

  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
    return isSignedIn() && isOwner(userId) && resource != null;
  }
}